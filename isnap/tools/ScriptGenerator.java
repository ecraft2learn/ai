import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.Scanner;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class ScriptGenerator {
	public static void main(String[] args) throws IOException {
		if (args.length != 3) {
			System.out.println("Usage: ScriptGenerator index.min.html compiled.min.js version.txt");
			return;
		}
		File versionFile = new File(args[2]);
		if (!versionFile.exists()) {
			System.out.println("Version file does not exist: " + args[2]);
			return;
		}
		Scanner sc = new Scanner(versionFile);
		String version = sc.next();
		sc.close();
		System.out.println("Generating scripts version " + version);
		generate(args[0], args[1], version);
	}

	public static void generate(String htmlPath, String output, String version) throws IOException {
		HashMap<String, Graph.Node> map = new LinkedHashMap<>();
		File htmlFile = new File(htmlPath);
		if (!htmlFile.exists()) throw new RuntimeException("No such file: " + htmlFile);
		htmlFile = htmlFile.getCanonicalFile();

		File root = htmlFile.getParentFile();
		String rootPath = root.getAbsolutePath();
		add(root, output, map);
		Graph.Node[] nodes = map.values().toArray(new Graph.Node[map.size()]);
		Arrays.sort(nodes);
		ArrayList<Graph.Node> sorted = Graph.topologicalSort(nodes);
//		System.out.println(sorted);

		// TODO: Make less rigid
		String newHtmlFile = htmlPath.replace(".min.html", ".html");
		String badLine = String.format("document.location = '%s'",
				getRelativePath(newHtmlFile, rootPath));

		PrintWriter writer = new PrintWriter(new FileWriter(newHtmlFile));
		writer.printf("<!-- NOTE: Do NOT edit this file directly. "
				+ "It is automatically from %s to include all necessary source files. -->\n",
				htmlFile.getName());

		Scanner sc = new Scanner(new FileInputStream(htmlFile));
		String snapFiles = "";
		String files = "";
		while (sc.hasNext()) {
			String line = sc.nextLine();
			if (line.contains("<script") && line.contains("</script>")) {
				if (!line.contains(output)) {
					// TODO: Use Regex to avoid required attribute order
					int start = line.indexOf("src=\"") + 5;
					int end = line.indexOf("\">");
					snapFiles += " " + getRelativePath(line.substring(start, end), rootPath);
					writer.println(
							line.replace("'>", "?v=" + version + "'>")
							.replace("\">", "?v=" + version + "\">"));
					continue;
				}
				String indent = "";
				for (int i = 0; i < line.length(); i++) {
					char c = line.charAt(i);
					if (c == ' ' || c == '\t') indent += c;
					else break;
				}
				writer.println();
				writer.println(indent + "<!-- Begin auto-generated script tags -->");
				// writer.println(indent + toScript("snap.min.js", rootPath, version));
				for (Graph.Node node : sorted) {
					System.out.println("Added script: " + getRelativePath(node.name, rootPath));
					if (!node.name.contains("config.js")) {
						writer.println(indent + toScript(node.name, rootPath, version));
						files += " " + getRelativePath(node.name, rootPath);
					}
				}
				// writer.println(indent + toScript("isnap.min.js", rootPath, version));
				writer.println(indent + "<!-- End auto-generated script tags -->");
				writer.println();
			} else if (line.contains(badLine)){
				writer.println("//" + line);
			} else if (line.contains("<link") && line.contains(">")) {
				// TODO: Use Regex to avoid required attribute order
				writer.println(
						line.replace("'>", "?v=" + version + "'>")
						.replace("\">", "?v=" + version + "\">"));
			}
			else {
				writer.println(line);
			}
		}
		sc.close();
		writer.close();

		// TODO: make work on unix :(
		String command = "uglifyjs" + snapFiles + " --source-map url=snap.min.js.map -o snap.min.js && ^\n" +
			"uglifyjs" + files + " --source-map url=isnap.min.js.map -o isnap.min.js\n";
		writeFile(new File(root, "tools/uglify.bat"), command);
		writeFile(new File(root, "tools/uglify.sh"), command);
	}

	private static void writeFile(File file, String content) throws IOException {
		PrintWriter writer = new PrintWriter(new FileWriter(file));
		writer.print(content);
		writer.close();
	}

	private static String toScript(String path, String rootPath, String version) {
		path = getRelativePath(path, rootPath);
		return String.format("<script type=\"text/javascript\" src=\"%s?v=%s\"></script>",
				path.replace(rootPath, ""), version);
	}

	private static String getRelativePath(String path, String rootPath) {
		path = path.replace("\\", "/");
		rootPath = rootPath.replace("\\", "/");
		if (path.startsWith(rootPath)) path = path.substring(rootPath.length());
		if (path.startsWith("/")) path = path.substring(1);
		return path;
	}

	private static Graph.Node getNode(String path, Map<String, Graph.Node> map) {
		if (map.containsKey(path)) return map.get(path);
		Graph.Node node = new Graph.Node(path);
		map.put(path, node);
		return node;
	}

	private static Pattern requirePattern =
			Pattern.compile("^\\s*require\\(['|\"]([a-zA-z0-9-_\\./ ]*)['|\"]\\)");

	private static void add(File root, String outFile, HashMap<String, Graph.Node> map)
			throws FileNotFoundException {
		for (String path : root.list()) {
			if (path.equals(outFile)) continue;
			File file = new File(root, path);
			if (path.equals(".git")) continue;
			if (file.isDirectory()) {
				add(file, outFile, map);
			}
			if (path.endsWith(".js")) {
				Scanner sc = new Scanner(new FileInputStream(file));
				int lineNumber = 0;
				while (sc.hasNextLine()) {
					String line = sc.nextLine();
					lineNumber++;
					Matcher matcher = requirePattern.matcher(line);
					if (matcher.find()) {
						int commentIndex = line.indexOf("//");
						if (commentIndex >= 0 && commentIndex < matcher.start()) continue;
						String requirement = matcher.group(1);
						if (!requirement.endsWith(".js")) requirement += ".js";
//						System.out.println(file.getName() + ": " + line);
						File requirementFile = new File(root, requirement);
						if (!requirementFile.exists()) {
							System.err.printf("Warning: dependency '%s' does not exist in %s:%d\n",
									requirement, file.getAbsolutePath(), lineNumber);
						}
						getNode(requirementFile.toPath().normalize().toString(), map).addEdge(
								getNode(file.getAbsolutePath(), map));
					}
				}
				sc.close();
			}
		}
	}

	// Credit: http://stackoverflow.com/questions/2739392/sample-directed-graph-and-topological-sort-code
	static class Graph {

		static class Node implements Comparable<Node> {
			public final String name;
			public final HashSet<Edge> inEdges;
			public final HashSet<Edge> outEdges;

			public Node(String name) {
				this.name = name;
				inEdges = new LinkedHashSet<Edge>();
				outEdges = new LinkedHashSet<Edge>();
			}

			public Node addEdge(Node node){
				Edge e = new Edge(this, node);
				outEdges.add(e);
				node.inEdges.add(e);
				return this;
			}

			@Override
			public String toString() {
				return name;
			}

			@Override
			public int compareTo(Node o) {
				return name.compareTo(o.name);
			}
		}

		static class Edge{
			public final Node from;
			public final Node to;

			public Edge(Node from, Node to) {
				this.from = from;
				this.to = to;
			}

			@Override
			public boolean equals(Object obj) {
				Edge e = (Edge)obj;
				return e.from == from && e.to == to;
			}

			@Override
			public int hashCode() {
				return from.hashCode() * 13 + to.hashCode();
			}
		}

//		public static void main(String[] args) {
//			Node seven = new Node("7");
//			Node five = new Node("5");
//			Node three = new Node("3");
//			Node eleven = new Node("11");
//			Node eight = new Node("8");
//			Node two = new Node("2");
//			Node nine = new Node("9");
//			Node ten = new Node("10");
//			seven.addEdge(eleven).addEdge(eight);
//			five.addEdge(eleven);
//			three.addEdge(eight).addEdge(ten);
//			eleven.addEdge(two).addEdge(nine).addEdge(ten);
//			eight.addEdge(nine).addEdge(ten);
//
//			Node[] allNodes = {ten, seven, five, three, eight, two, nine, eleven};
//			topologicalSort(allNodes);
//		}

		private static ArrayList<Node> topologicalSort(Node[] allNodes) {
			//L <- Empty list that will contain the sorted elements
			ArrayList<Node> L = new ArrayList<Node>();

			//S <- Set of all nodes with no incoming edges
			Set<Node> S = new LinkedHashSet<Node>();
			for(Node n : allNodes){
				if(n.inEdges.size() == 0){
					S.add(n);
				}
			}

			//while S is non-empty do
			while(!S.isEmpty()){
				//remove a node n from S
				Node n = S.iterator().next();
				S.remove(n);

				//insert n into L
				L.add(n);

				//for each node m with an edge e from n to m do
				for(Iterator<Edge> it = n.outEdges.iterator();it.hasNext();){
					//remove edge e from the graph
					Edge e = it.next();
					Node m = e.to;
					it.remove();//Remove edge from n
					m.inEdges.remove(e);//Remove edge from m

					//if m has no other incoming edges then insert m into S
					if(m.inEdges.isEmpty()){
						S.add(m);
					}
				}
			}
			//Check to see if all edges are removed
			for(Node n : allNodes){
				if(!n.inEdges.isEmpty()){
					return null;
				}
			}

			return L;
		}
	}
}
